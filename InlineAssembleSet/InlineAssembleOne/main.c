//
//  main.c
//  InlineAssembleOne
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

//定义全局变量
char* str = "Hello,World\n";
int count = 0;//返回打印的字符数
int int_a = 1, int_b = 2, out_sum;

int main(int argc, const char * argv[]) {
    
    //直接调用系统调用显示字符串,系统调用执行后返回打印的字符数
    asm("pusha;            \
        movl $4,%eax;    \
        movl $1,%ebx;    \
        movl str,%ecx;    \
        movl $12,%edx;    \
        int $0x80;        \
        mov %eax,count;    \
        popa            ");
    printf("count=%d\n", count);//12
    //基本内联汇编,两数相加
    asm("pusha;                \
        movl int_a,%eax;    \
        movl int_b,%ebx;    \
        addl %ebx,%eax;        \
        mov %eax,out_sum;    \
        popa                ");
    printf("out_sum=%d\n", out_sum);//3
    //扩展内联汇编,两数相加,如果使用扩展内联汇编,变量可以是局部变量
    asm("addl %%ebx,%%eax" : "=a"(out_sum) : "a"(int_a), "b"(int_b));//寄存器约束
    printf("out_sum=%d\n", out_sum);//3
    //扩展内联汇编,两数相加,如果使用扩展内联汇编,变量可以是局部变量
    asm("addl %%ebx,%%eax" : "=a"(out_sum) : "a"(int_a), "b"(int_b));//寄存器约束
    printf("out_sum=%d\n", out_sum);//3
}

//基本内联汇编
//pusha:将8个通用寄存器压栈(Intel中是pushad)
//传入write的调用号4
//int $0x80执行系统调用
//将系统调用返回值eax写到count
//
//基本内联汇编格式    asm [volatile] ("assembly code")
//各个关键字之间可以用空格或制表符隔开,也可以紧凑挨在一起,关键字asm用于声明内联汇编表达式,不可少
//asm和_asm_是一样的,是由gcc定义的宏:    #define _asm_ asm
//因为gcc有个优化选项-O,可以指定优化级别,当用-O编译时,gcc按照自己的意图优化代码,关键字volatile是可选项,告诉编译器不要优化原样保留
//volatile和_volatile_是一样的,是由gcc定义的宏:        #define _volatile_ volatile
//"assembly code"是汇编代码,必须位于圆括号中,而且必须用""引起来,这是格式要求,满足要求,assembly code可以为空
//规则如下:
//1.指令必须用双引号引起来,不论双引号中是一条指令还是多条指令
//2.一对双引号不能跨行,如果跨行需要在行尾加上\
//3.指令之间用分号; . \n或者\n\t分隔
//
//在基本内联汇编中若要引用C变量,只能将它定义为全局变量,如果定义为局部变量,链接时会找不到这两个符号,这就是基本内联汇编的局限性
//
//gcc本身是个C编译器,要让其支持汇编语言,必然牵扯到以下问题:
//1.在内联汇编代码插入点之前的C代码,其编译后也要被分配寄存器等资源,插入的汇编代码也要使用寄存器,是否会造成资源冲突
//2.汇编语言如何访问C语言中的变量
//从头分析,假设没有扩展内联汇编,当汇编代码嵌入到C代码中,如果汇编代码想把C中的变量最为操作数加载到寄存器,如何找到可用的寄存器?
//这可是个大问题,程序员并不知道哪个寄存器己经被分配了,哪些寄存器是空闲的,即便知道了寄存器的分配情况也还不够
//有些底层操作对寄存器的要求是固定的,比如in/out指令,就得使用al作为数据寄存器,万一那个固定的寄存器已经被占用了
//在使用前还得把它备份,也许您觉得,这些问题不难啊,我不管之前用了哪些寄存器,我在内联汇编中用哪些寄存器时就先将其入栈备份,用完了再恢复
//昕上去不错,但由用户来保证数据完整性简直就是灾难,人的精力是有限的,谁知道会不会漏掉哪个寄存器呢,而且在出了问题后也不容易查出来
//而且运行中有大量的压栈操作,访问内存本身就比较慢,不如在编译阶段由编译器优化,直接分配给寄存器或用寄存器缓存,这样程序运行才更快
//所以这类事情还是交给编译器自己做这事才放心,既然编译器对咱们不放心,那么现在的问题变成了如何将C代码中的变量变成汇编代码中的操作数
//由于编译器无法预测用户的需求,这些只得让用户控制,故编译器采取的做法是它提供一个模板,让用户在模板中提出要求,其余工作由它负责实现
//这些用户提出的要求就是后面所说的约束
//
//基本内联汇编格式
//asm [volatile] ("assembly code")
//
//扩展内联汇编格式
//asm [volatile] （"assembly code" : output : input : clobber/modify)
//
//其中的每一部分都可以省略,甚至包括assembly code,省略的部分要保留冒号分隔符来占位
//如果省略的是后面的一个或多个连续的部分,分隔符也不用保留,比如省略了 clobber/modify,不需要保留input后面的冒号
//其中的每一部分都可以省略,甚至包括assembly code,省略的部分要保留冒号分隔符来占位
//如果省略的是后面的一个或多个连续的部分,分隔符也不用保留,比如省略了clobber/modify,不需要保留input后面的冒号
//在C代码中内嵌汇编的目的是让汇编帮助C完成某些功能,所以C代码就要为其提供参数和用于存放其输出结果的空间
//output:output用来指定汇编代码的数据如何输出给C代码使用,内嵌的汇编指令运行结束后,如果想将运行结果存储到C变量中,就用此项指定输出的位置
//output中每个操作数的格式为:
//    "操作数修饰符约束名"(C变量名)
//其中的引号和圆括号不能少,操作数修饰符通常为等号=,多个操作数之间用逗号,分隔
//
//input:input用来指定C中数据如何输入给汇编使用,要想让汇编使用C中的变量作为参数,就要在此指定
//input中每个操作数的格式为:
//    "[操作数修饰符]约束名"(C变量名)
//其中的引号和圆括号不能少,操作数修饰符为可选项,多个操作数之间用逗号,分隔
//单独强调一下,以上的output()和input()括号中的是C代码中的变量,output(C变量)和input(C变量)
//就像C语言中的函数,将C变量(值或变量地址)转换成汇编代码的操作数
//
//clobber/modify:汇编代码执行后会破坏一些内存或寄存器资源,通过此项通知编译器可能造成寄存器或内存数据的破坏
//这样gcc就知道哪些寄存器或内存需要提前保护起来,后面会展开细说
//assembly code中引用的所有操作数其实是经过gcc转换后的复本,原件都是在output和input括号中的C变量
//
//约束所起的作用就是把C代码中的操作数(变量/立即数)映射为汇编中所使用的操作数,实际就是描述C中的操作数如何变成汇编操作数
//这些约束的作用域是input和output部分,约束分为四大类
//
//1.寄存器约束
//寄存器约束就是要求gcc使用哪个寄存器,将input或output中变量约束在某个寄存器中,常见的寄存器约束有:
//a;表示寄存器 eax/ax/al
//b:表示寄存器 ebx/bx/bl
//c;表示寄存器 ecx/cx/cl
//d:表示寄存器 edx/dx/dl
//D:表示寄存器 edi/di
//S:表示寄存器 esi/si
//q:表示任意这4个通用寄存器之－:eax/ebx/ecx/edx
//r:表示任意这6个通用寄存器之一:eax/ebx/ecx/edx/esi/edi
//g:表示可以存放到任意地点(寄存器和内存),相当于除了同q一样外,还可以让gcc安排在内存中
//A:把eax和edx组合成64位整数
//f:表示浮点寄存器
//t:表示第1个浮点寄存器
//u:表示第2个浮点寄存器
//
//2.内存约束
//内存约束是要求gcc直接将位于input和output中的C变量的内存地址作为内联汇编代码的操作数,不需要寄存器做中转
//直接进行内存读写,也就是汇编代码的操作数是C变量的指针
//m:表示操作数可以使用任意一种内存形式
//o:操作数为内存变量,但访问它是通过偏移量的形式访问,即包含offset_address的格式
//
//3.立即数约束
//立即数即常数,此约束要求gcc在传值的时候不通过内存和寄存器,直接作为立即数传给汇编代码
//由于立即数不是变量,只能作为右值,所以只能放在input中
//i:表示操作数为整数立即数
//F:表示操作数为浮点数立即数
//I:表示操作数为0～31之间的立即数
//J:表示操作数为0～63之间的立即数
//N:表示操作数为0～255之间的立即数
//O:表示操作数为0～32之间的立即数
//X:表示操作数为任何类型立即数
//为了节约篇幅,将立即数约束同其他约束一起演示
//
//4.通用约束
//0～9:此约束只用在input部分,但表示可与output和input中第n个操作数用相同的寄存器或内存
//
//由于我们是在C语言中插入汇编代码,所以约束的作用是让C代码的操作数变成汇编代码能使用的操作数
//所有的约束形式其实都是给汇编用的,故约束是C语言中的操作数(变量或立即数)与汇编代码中的操作数之间的映射
//它告诉gcc,同一个操作数在两种环境下如何变换身份,如何对接沟通,编译过程中C代码是要先变成汇编代码的
//内联汇编中的约束相当于gcc让咱们指定C中数据的编译形式,在内联汇编中assembly code中用到的操作数都是位于output和input中C操作数的副本
//多数通过赋值的方式传给汇编代码,或者顶多是通过指针的形式,当操作数的副本在汇编中处理完成后,又重新赋值给C操作数
//也可以这么说,C操作数通过约束后在汇编中的操作数是约束所指定的那个操作数载体,即内存或寄存器
//如果是寄存器约束,汇编中操作的并不是C变量本身,而是C变量通过值传递到汇编的副本,比如
//int int_a = 1, int_b = 2;
//asm("movl %%eax,%%ebx" : : "a"(int_a ),"b"(int_b));
//声明了两个C变量int_a和int_b,在汇编代码中,表面上看是把变量int_a复制到了变量int_b中
//但我们知道movl指令不能是从内存到内存的复制,所以movl的操作数是C变量int_a和int_b通过约束指定的操作数载体:寄存器eax和ebx
//
//关于占位符
//假设我们用a指定寄存器为eax,我们在汇编代码中可以用eax作为操作数,但有时我们对寄存器的要求并不严格,使用哪个都可以
//所以我们可以用r来告诉gcc替我们自由安排,于是问题来了,由于r表示可以用6个寄存器之一,我们并不知道gcc为操作数分配了哪个寄存器
//或者我们对操作数用了内存约束,操作数没有名称可以引用,这时候我们在汇编代码中该如何引用操作数呢?
//为方便对操作数的引用,扩展内联汇编提供了占位符,它的作用是代表约束指定的操作数(寄存器/内存/立即数)
//我们更多的是在内联汇编中使用占位符来引用操作数,占位符分为序号占位符和名称占位符两种
//1.序号占位符
//序号占位符是对在output和input中的操作数,按照它们从左到右出现的次序,从0开始编号一直到9,也就是说最多支持10个序号占位符
//操作数用在assembly code中,引用它的格式是%0～9,在操作数自身的序号前面加1个百分号%,便是对相应操作数的引用
//一定要切记,占位符指代约束所对应的操作数,也就是在汇编中的操作数,并不是圆括号中的C变量,比如:
//
//asm("addl %%ebx,%%eax":"=a"(out_sum) : "a"(int_a), "b"(int_b));等价于
//asm("addl %2,%1":"=a"(out_sum) : "a"(int_a), "b"(int_b));
//
//"=a"(out_sum)序号为0,%0对应的是eax
//"a"(int_a)序号为1,%1对应的是eax
//"b"(int_b)序号为2,%2对应的是ebx
//
//由于扩展内联汇编中的占位符要有前缀%,为了区别占位符和寄存器,只好在寄存器前用两个%做前缀,解释了在扩展内联汇编中寄存器前面要有两个%做前缀的原因
//占位符所表示的操作数默认情况下为32位数据,指令的操作数大小并不一致,有的指令操作数大小是32位,有的是16位,有的是8位
//当为这些指令提供操作数时,编译器会自动取32位数据的低16位给需要16位操作数的指令,取32位的低8位给需要8位操作数的指令
//由于32位数据中,高16位设法直接使用,所以对于16位操作数只能取32位中的低16位,但对于8位操作数就不一样了
//尽管默认情况下会用低8位作为字节指令的操作数,但32位数据中能直接使用的字节不只是低8位,还有第8～15位
//所以对于宇节指令,gcc为我们提供了改变默认操作数的机会,我们可以自由选择是用0～7位,还是8～15位,这么说有点抽象
//拿32位的寄存器eax举例,其常用的部分是eax/ax/al(高16位没法直接用)
//有些指令的操作数是宇,所以用ax做操作数即可,有些指令操作数是字节,用al或ah都可以,默认情况下会将al当作操作数
//这时候我们可以在%和序号之间插入字符h来表示操作数为ah,或者插入字符b来表示操作数为al
//不知道大伙儿有没有稍感意外,怎么又冒出个字符h和字符b,其实它们并不孤独,它们的同类很多呢,这是属于机器模式中的内容
//gcc允许在更细的粒度上指定数据宽度或数据的某部分
//
//
//2.名称占位符
//名称占位符与序号占位符不同,序号占位符靠本身出现在output和input中的位置就能被编译器辨识出来
//而名称占位序需要在output和input中把操作数显式地起个名字
//它用这样的格式来标识操作数:    [名称]"约束名"(C变量)
//这样该约束对应的汇编操作数便有了名字,在assembly code中引用操作数时,采用%[名称]的形式就可以了
//
//
//本系列内联汇编程序只在Linux下编译运行,使用gcc编译时加上-m32选项以生成32位程序
//64位系统编译32位代码,出现/usr/include/gnu/stubs.h:7:27:致命错误:gnu/stubs-32.h:没有那个文件或目录,需要安装32位的glibc库文件
//安装32位glibc库文件命令:
//sudo yum install glibc-devel.i686(安装C库文件)
//sudo dnf install glibc-devel.i686(fedora命令)
//
//安装32位glibc++库文件命令
//sudo yum install libstdc++ - devel.i686
//sudo dnf install libstdc++ - devel.i686(fedora命令)
//Ubuntu解决命令:
//sudo apt-get install g++-multilib
//深度系统下编译选项-m32出现错误:bits/libc-header-start.h: 没有那个文件或目录
//sudo apt-get install gcc-multilib
