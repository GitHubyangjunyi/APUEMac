//
//  main.c
//  InlineAssembleNine
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[]) {
  
    int int_a = 1, sum = 0;
    asm("addl %1,%0;" : "=a"(sum) : "%I"(2), "0"(int_a));
    printf("sum is %d\n", sum);//3
}

//损坏通知三
//演示了修饰符%/立即数约束/通用约束的用法,无实际意义
//"%I"(2)表示传了一个立即数2,并用了立即数约束I,这会让gcc将数字2变成汇编语言中的立即数$2
//在这个输入中,还用到了修饰符%,这表示约束I对应的操作数可以和下一个输入所约束的操作数对换位置
//下一个输入是"0"(int_a),通用约束0,这表示要求gcc把分配给C变量int_a的操作数(寄存器或内存)同序号0对应的汇编操作数一样
//也就是说,位于output和input中序号为0的输入,其所约束的操作数(寄存器或内存)是什么,就把我安排成什么
//序号0是"=a"(sum),约束a将寄存器eax分配给变量sum,所以int_a也被分配为eax,这有点类似修饰符+同时可读可写
//
//
//3.立即数约束
//立即数即常数,此约束要求gcc在传值的时候不通过内存和寄存器,直接作为立即数传给汇编代码
//由于立即数不是变量,只能作为右值,所以只能放在input中
//i:表示操作数为整数立即数
//F:表示操作数为浮点数立即数
//I:表示操作数为0～31之间的立即数
//J:表示操作数为0～63之间的立即数
//N:表示操作数为0～255之间的立即数
//O:表示操作数为0～32之间的立即数
//X:表示操作数为任何类型立即数
//为了节约篇幅,将立即数约束同其他约束一起演示
//
//4.通用约束
//0～9:此约束只用在input部分,但表示可与output和input中第n个操作数用相同的寄存器或内存
//
//由于我们在C程序中嵌入了汇编代码,这必然会造成一些资源的破坏,本来C代码翻译后也要用到寄存器,突然来了一堆抢寄存器用的汇编指令
//这肯定会使gcc重新为C代码安排寄存器等资源,为了解决资源冲突,我们得让gcc知道我们改变了哪些寄存器或内存,这样gcc才能合理安排
//如果在output和input中通过寄存器约束指定了寄存器,gcc必然会知道这些寄存器会被修改,所以需要在clobber/modify中
//通知的寄存器肯定不是在output和input中出现过的,也许您会认为,牵扯到修改寄存器或内存的部分
//只差assembly code没说了,这部分还需要咱们明确告诉编译器吗?编译器不会自己扫描汇编指令?用到了哪些寄存器它还不知道吗?
//是的gcc还真不是很有把握知道哪些资源会被修改,在"明处"的指令确实可以检测到所修改的资源
//比如此incl %%eax,这种明显的改变gcc当然能扫描出来,可"暗处"的指令就无法保证了,比如在汇编中调用了一个函数
//该函数内部会修改一些资源,或者该函数中又调用了其他函数,这保不准在哪一层调用有修改资源的代码,简直无法跟踪,所以必须要人为显式地
//告诉gcc我们动了哪些资源,这个资源就是寄存器和内存,怎样通知gcc我们修改了哪些寄存器?
//这个很简单,只要在clobber/modify部分明确写出来就行了,记得要用双引号把寄存器名称引起来,多个寄存器之间用逗号分隔
//这里的寄存器不用再加两个%啦,只写名称即可,比如:
//    asm ("movl %%eax,%0;movl %%eax,%%ebx" : "=m"(ret_value) ::"bx")
//
//大家看,虽然修改的是寄存器ebx,但只要在clobber/modify声明bx就可以了,甚至可以声明al
//原因是即使寄存器只变动一部分,它的整体也会全跟着受影响,所以在clobber/modify中声明寄存器时
//可以用低8位名称/低16位名称/全32位名称,如"al"/"ax"/"eax"都是指eax寄存器,其他通用寄存器也是一样的
//如果我们的内联汇编代码修改了标志寄存器eflags中的标志位,同样需要在clobber/modify中用"cc"声明
//如果我们修改了内存,我们需要在clobber/modify中"memory"声明
//如果我们在output中使用了内存约束,gcc自然会得到哪块内存被修改,但如果被修改的内容并未在output中,我们就需要用"memory"告诉gcc
//举个例子,还记得之前咱们所说的复制大块数据的三剑客指令吗?
//字符串指令movsd配合cld和rep,通过指针esi和edi的不断变化使源数据被复制到新目的地,后来数据被复制到了哪里,修改了哪些内存
//gcc可就不知道了,咱得主动用"memory"坦白才行,另外一个用"memory"声明的原因就是清除寄存器缓存
//内存相对寄存器来说还是比较慢的,gcc为了提速,编译中有时会把内存中的数据缓存到寄存器,之后的处理都是直接读取寄存器
//编译过程中编译器无法检测到内存的变化,只有编译出来的程序在实际运行中才会出现变量的值被改变
//也就是出现了内存变化的情况,您想,如果程序在编译阶段就能检测程序行为的话,那还运行程序干吗,直接在该程序的编译阶段输出程序运行结果不就完了吗
//于是问题来了,编译器编译程序时,将变量的值缓存到寄存器,程序在运行时,当变量所在的内存有变化时,寄存器中的缓存还是旧数据
//运行结果肯定就错了,于是gcc也为我们提供了选项,用来设置是否将变量缓存到寄存器中,这个选项就是C语言中的关键宇volatile
//它表示该变量是不稳定的容易被改变,这样gcc就不会将其缓存到寄存器,注意啦,这个关键字并不是内联汇编asm后面的可选项[volatile]
//虽然名字是一样的,但汇编中的volatile是定义的宏＃define _volatile_ volatile,在编译前的预处理阶段,汇编中的volatile最终会变成＿volatile_
//这和C语言中的volatile不冲突,用C语言中的volatile定义的变量,编译器就不会将该变量的值缓存到寄存器中,每次访问该变量时都会
//老老实实地从内存中获取,也就是说,只要编译器知道变量所在的内存有变化,它就会放弃寄存器缓存,到内存中取数据
//利用这个原理,不管变量的值是否会被编译器缓存到寄存器中,当我们需要绕过寄存器缓存,也就是希望读取到内存中最新的数据时
//我们就可以在内联汇编中的clobber/modify部分用"memory"声明,通知编译器变量所在的内存数据变啦,这样它就会从内存再读取一次新数据啦
//当然我们也可以在C代码中用volatile去修饰所定义的变量,但变量多了就有些麻烦了,所以还是用"memory"来声明更加方便
