//
//  main.c
//  InlineAssembleSix
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[]) {
    
    int int_a = 1, int_b = 2;
    asm("addl %%ebx,%%eax" : "+a"(int_a) : "b"(int_b));
    printf("int_a is %d\n", int_a);//3
    
    //asm("addl %%ebx,%%eax" : "+a"(int_a) : "b"(int_b));//正确
    //asm("addl %%ebx,%%eax" : "a"(int_a) : "b"(int_b));//错误,如果没有+号将会出现编译错误
    //错误:输出操作数约束缺少=
    //错误:汇编输出 0 中左值无效
}

//关于操作数类型修饰符
//强调与总结:
//无论是哪种占位符,它都是指代C变量经过约束后,由gcc分配的对应于汇编代码中的操作数,和C变量本身无关
//这个操作数就是通过约束名所指定的寄存器/内存/立即数等,最终编译器要将占位符转换成这三种操作数类型之一
//在约束中还有操作数类型修饰符,用来修饰所约束的操作数:内存/寄存器,分别在output和input中有以下几种
//在output中有以下3种
//＝:表示操作数是只写,相当于为output括号中的C变量赋值,如＝a(c_var),此修饰符相当于c_var=eax
//＋:表示操作数是可读写的,告诉gcc所约束的寄存器或内存先被读入,再被写入
//＆:表示此output中的操作数要独占所约束(分配)的寄存器,只供output使用,任何input中所分配的寄存器不能与此相同
//需要注意,当表达式中有多个修饰符时,＆要与约束名挨着,不能分隔
//在input中:
//%:该操作数可以和下一个输入操作数互换
//一般情况下,input中的C变量是只读的,output中的C变量是只写的,修饰符=只用在output中,表示C变量是只写的,功能相当于output中的C变量＝约束的汇编操作数
//如"=a"(c_var)相当于c_var=eax的值
//修饰符+也只用在output中,但它具备读/写的属性,也就是它既可作为输入,同时也可以作为输出,所以省去了在input中声明约束
//
//另一个+常用的场合是在"rep＋字符串操作指令＋cld"或"std"指令组合中,原因是在字符串操作指令中
//esi作为源变址,保存数据所在的源地址,在字符串操作指令执行前,esi要作为数据源地址,所以当作参数被读入,成了输入对象
//在字符串操作指令执行后,esi也要被更新为下一个数据源的地址,此时esi又被写入,成了输出对象,所以esi是先被读入后被写入
//非常适合用+来修饰,edi作为目的变址,保存数据写入的目的地址
//在字符串操作指令执行前,edi要作为数据写入的目的地址,所以当作参数被读入,成了输入对象,在宇符串操作指令执行后,edi也要被更新为下一个数据所写入的目的地址
//此时edi又被写入,成了输出对象,所以edi也是先被读入,后被写入,非常适合用+来修饰
//注意,常见的字符串操作指令有movs[bwd]    ins[bwd]    outs[bwd]    lods[bwd]    stos[bwd]
//但是esi和edi并不是被以上三组指令同时使用,只有movs[bwd]才同时使用esi和edi,它是把esi所指向的地址处的数据复制到edi所指向的内存地址处
//ins[bwd]是从端口读入数据到内存的目的地址,故只涉及到edi
//outs[bwd]是把内存中的源数据写入端口,故只涉及到esi
//lods[bwd]是把内存中的源数据加载到寄存器al/ax/eax,故只涉及到esi
//stos[bwd]是将寄存器al/ax/eax中的值写入内存中的目的地址,故只涉及到edi
//以上字符串指令每执行一次,所涉及到的源变址寄存器esi或目的变址寄存器edi都要根据操作数大小有所增减
//至于是增加还是减少,要取决于标志寄存器中的方向位DF,若DF=O,esi和edi都自增,地址值越来越大,否则DF=1,esi和edi都自减,地址值越来越小
//这些字符串操作指令在读写数据时,esi和edi作为它们的输入操作数,执行完成后,根据DF位的情况自增或自减,这时又作为输出
//以后在用内联汇编写I/O端口函数时会用到,此处不再单独举例
//
//修饰符＆用来表示此寄存器只能分配给output中的某个C变量使用,不能再分给input中某变量了,函数执行完成时,返回值会存储在寄存器eax中
//通常我们会将返回值获取到C变量中再处理,如果是让gcc自由分配寄存器,gcc有可能把eax分配出去另做他用
//有可能的一种情况是先调用函数,函数返回后又执行了其他操作,这个操作中用到了gcc分配的eax寄存器,于是函数的返回值便被破坏
