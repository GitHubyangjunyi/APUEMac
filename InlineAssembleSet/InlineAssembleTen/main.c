//
//  main.c
//  InlineAssembleTen
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[]) {
   
    int int_a = 0x1234, int_b = 0;
    //asm("movw %1,%0;" : "m"(int_b) : "a"(int_a));//编译警告大意是由于w前缀,用寄存器ax代替eax
    //操作码w的意义,它表示:即使操作数不是一个字那样的大小,也要像一个字那样把它打印出来
    //简而言之就是不管操作数多少个字节,只打印2宇节
    asm("movw %w1,%0;" : "=m"(int_b) : "a"(int_a));
    printf("int_b now is 0x%x\n", int_b);//输出0x1234
    
}

//机器模式
//在前面介绍序号占位符的时候已经引出了机器模式的内容,为了指定寄存器中的某部分,引用了字符h和字符b
//它们分别用来指定寄存器的第8～15位和低8位,这只是机器模式的用途之一,比如寄存器约束a表示寄存器al/ax/eax
//可以在序号占位符中增加前缀字符h和b来引用寄存器ah和al,不过这次我不想指定ah或al啦,如果我想指定ax或eax,又要怎么做?
//
//机器模式用来在机器层面上指定数据的大小及格式,由于各种约束均不能确切地表达具体的操作数对象
//所以引用了机器模式,用来从更细的粒度上描述数据对象的大小及其指定部分
//实际上操作码就是指定操作数为寄存器中的哪个部分,这里不用关注太多,初步了解h/b/w/k这几个操作码就够了,以后有需要时再说
//寄存器按是否可单独使用可分成几个部分,拿eax举例
//低部分的一字节:al
//高部分的一字节:ah
//两字节部分:ax
//四字节部分: eax
//h:输出寄存器高位部分中的那一字节对应的寄存器名称,如ah/bh/ch/dh
//b:输出寄存器中低部分1字节对应的名称,如al/bl/cl/dl
//w:输出寄存器中大小为2个宇节对应的部分,如ax/bx/cx/dx
//k:输出寄存器的四字节部分,如eax/ebx/ecx/edx
