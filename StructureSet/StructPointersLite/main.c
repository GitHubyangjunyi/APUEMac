//
//  main.c
//  StructPointersLite
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

struct pointer
{
    int x;
    int y;
};

int main(int argc, const char * argv[]) {
    
    struct pointer p;//从现代语义上讲,p就是一个结构体对象,x和y各是其成员
    p.x = 10;        //从汇编语义上讲,p是一个不完整的地址,或者说是一个指向的东西是虚构出来的地址
    p.y = 100;        //而x和y各是在结构中的地址偏移量,也就是说必须要有p和x或者p和y同时出现才有意义
    //早期的C就是在这样的模型上建立的,对早期C来说,*pp没有意义,你取得了一个结构
    struct pointer *pp;//而这个结构不能装进任意一个寄存器里,处理器和编译器无法表达这个东西
    pp = &p;        //所以早期的C可以有下面的语句
    int *a;
    a = &(p.x);//合法
    (*pp).x = 1;//在早期的C中,这一句是不合法的,因为作为这个赋值的目标地址表达式的一部分,*pp,这个中间结果无法直译到机器码
    //所以对早期的C而言,对pp解引用的操作必须和取成员的偏移的操作结合起来成为一个单独的操作,其结果才有意义
    pp->x = 66666;//所以早期的C就发明了->,表示这两个紧密结合起来的操作,就像右侧的代码那样
    printf("%d\n", pp->x);//而这个历史原因现在已经不重要了,现代的符合标准的C编译器都知道(*pp).x和pp->x是等价的了
    
    printf("%d\n", (*pp).y);//首先就是对指针执行间接访问获得这个结构,然后使用点操作符来访问它的成员
    //printf("%d\n", sp.x);//这一行的写法是错误的,sp是结构体指针,要先进行间接访问取得结构,再用点操作符获取成员,这就导致了上一行写法的繁琐
    printf("%d\n", pp->x);//为解决繁琐而出现的方便的写法,直接访问,省去括号
    
    
    return 0;
}

//指向结构的指针以及运算符->简化版
//
//结构变量的成员是通过点操作符(.)访问,点操作符接受两个操作数,左操作数就是结构变量的名字,右操作数就是需要访问的成员的名字
//这个表达式的结果就是指定的成员
//
//如果已经获得了一个指向结构的指针,要访问这个结构的成员:
//首先就是对指针执行间接访问获得这个结构,然后使用点操作符来访问它的成员
//但是点操作符的优先级高于间接访问操作符,所以必须在表达式中添加括号,确保间接访问首先执行
//假定一个函数的参数是指向结构的指针,原型如下:
//    void func( struct COMPLEX *cp );
//函数可以使用下面这个表达式来访问这个变量所指向的结构的成员f
//(*cp).f
//对指针执行间接访问将访问结构,然后点操作符访问一个成员
//
//由于这个概念比较讨厌,所以C语言提供了一个更为方便的操作符来完成这项工作    ->箭头操作符
//和点操作符一样,箭头操作符接受两个参数,但左操作数必须是一个指向结构的指针
//->箭头操作符对左操作数执行间接访问取得指针所指向的结构,然后和点操作符一样
//根据右操作符选择一个指定的结构成员
//但是间接访问操作内建于箭头操作符中,所以我们不需要显示地执行间接访问或使用括号
