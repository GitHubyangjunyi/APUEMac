//
//  main.c
//  MemoryLeak
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int main(int argc, const char * argv[]) {
    
    //内存丢失跟踪
    char *chunk;
    /*while (true)
     {
     chunk = (char *)malloc(100000000);
     printf("Allocating\n");
     }*/
    //堆一般利用操作系统的功能来管理内存,堆的大小可能在程序创建后就固定不变了,也可能可以增长
    //不过堆管理器不一定会在调用free函数时将内存返还给操作系统,释放的内存只是可供应用程序的后续使用
    //所以如果程序先分配内存后释放,从操作系统角度看,释放的内存通常不会反应在应用程序的内存使用上
    
    //完全丢失地址
    int *p = (int *)malloc(sizeof(int));
    *p = 5;
    p = (int *)malloc(sizeof(int));//由于没有释放前面的地址,程序已经没有地方持有前一次分配的地址了
    
    //丢失起始地址
    char *name = (char *)malloc(strlen("Susan") + 1);
    strcpy(name, "Susan");
    while (*name != 0)
    {
        printf("%c", *name);
        name++;
    }
    
    //隐式内存泄漏
    //如果程序应该释放内存而实际没有释放也会发生泄漏,如果不再需要某个对象但依然保存在堆上,就会发生隐式内存泄漏
    //这类泄漏的问题主要是对象在使用的内存起始已经不在需要了,应该归还给堆
    //在释放struct关键字创建的结构体时也可能发生内存泄漏,如果结构体包含指向动态分配内存的指针,那么可能需要在释放结构体之前先释放这些指针
    
    
    return 0;
}

//内存泄漏的一个问题是无法回收内存并重复使用,堆管理器的可用内存将变少,极端情况下,操作系统可能会崩溃
//chunk变量指向堆上的内存,然而在它指向另一块内存之前没有释放该内存块,最终程序将用光内存然后非正常终止,即使没有终止,内存的利用率也不高
//
//几个内存分配函数
//    malloc    从堆上分配内存不清零    void* malloc(size_t)    可分配的最大内存跟系统相关,看起来这个大小由size_t限制,不过可能受物理可用内存和操作系统的其他限制
//    realloc    在之前分配的内存块的基础上,将内存重新分配为更大或更小的部分
//    calloc    从堆上分配内存并清零
//    free    将内存块返回堆
//动态内存从堆上分配,至于一连串内存分配调用,系统不保证内存的顺序和所分配内存的连续性
//不过分配的内存根据指针的数据类型对齐,比如4字节的整数会分配在能被4整除的地址边界上,堆管理器返回的地址是最低字节地址
//malloc函数从堆上分配一块内存,所分配的字节数由该函数唯一参数指定,返回值是void指针,如果内存不足返回NULL
//此函数不会清空或修改内存,所以新分配的内存包含垃圾数据
//如果参数是负数在有些系统中返回NULL
//如果参数是0其行为与具体实现相关,可能返回NULL指针,也可能返回一个指向分配了0字节区域的指针
//如果参数是NULL,那么一般会生成一个警告并返回0字节
//
//在C引入void指针之前,在两种互不兼容的指针类型之间赋值需要对malloc使用显式转换类型以避免产生警告
//因为可以将void指针赋值给其他任何指针类型,所以就不在需要显示类型转换了
