//
//  main.c
//  BlockStructure
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[]) {
    
    //编译器根据{}来做出入栈操作管理变量的作用域
    int x = 100;
    {
        int x = 10;
        printf("%d\n", x);
    }
    printf("%d\n", x);
    
    printf("staticint = %d\n", statictest());//0
    printf("staticint = %d\n", statictest());//1
    printf("staticint = %d\n", statictest());//2
    
    
    return 0;
}

int statictest(void)
{
    static int staticint = 0;
    return staticint++;
}

//块结构与作用域
//函数中的每个局部变量只在函数被调用时存在,执行完毕退出时消失,称为自动变量的原因
//由于自动变量只在函数调用执行期间存在,所以在函数两次调用之间,不保留前次调用时的赋值
//且在每次进入函数时都要显式赋值,如果自动变量没有赋值,其中存放的是无效值
//
//static存储类,这种类型的局部变量在多次函数调用之间保持值不变
//
//除了自动变量外还可以定义位于所有函数外部的变量,所有的函数都可以通过变量名访问这种变量
//由于外部变量可以在全局范围内访问,函数间可以通过外部变量交换数据,而不必使用参数表
//外部变量在程序执行期间一直存在,即使在对外部变量赋值的函数返回后,这些变量依旧保持原来的值不变
//外部变量必须定义在所有函数外,且只能定义一次,定义后编译程序将为它分配存储单元
//在每个需要访问外部变量的函数中,必须声明相应的外部变量,此时说明其类型
//声明时使用extern显示声明,也可以通过上下文隐式声明
//函数在使用外部变量之前必须要知道,一种方式是在函数中使用extern类型的声明
//某些情况下可以省略extern声明,在源文件中,如果外部变量的定义出现在使用它的函数之前,那么在那个函数中就没有必要使用extern声明
//通常的做法是,所有外部变量的定义都放在源文件的开始处,这样就可以省略extern声明
//
//如果程序包含在多个源文件中,而某个变量在file1中定义,而在file2和file3中使用
//那么在file2和file3中就需要使用extern声明来建立该变量与其定义之间的联系
//通常把变量和函数的extern声明放在一个单独的文件中,一般称为头文件
//并在每个源文件的开头使用#include包含进来,并约定头文件后缀名.h
//标准库中的函数就是在类似于<stdio.h>的头文件中声明的
//
//定义表示创建变量或分配存储单元,而声明指的是说明变量的性质,但并不分配存储单元
//定义表示创建变量或分配存储单元,而声明指的是说明变量的性质,但并不分配存储单元
//
//构成C语言程序的函数和外部变量可以分开进行编译,一个程序可以存放在几个文件中,原先以编译过的函数可以从库中进行加载,这里我们感兴趣的问题有:
//    1.如何进行声明才能确保变量在编译时被正确声明?
//    2.如何安排声明的位置才能确保程序在加载时各部分能正确连接?
//    3.如何组织程序中的声明才能确保只有一份副本?
//    4.如何初始化外部变量
//
//名字的作用域是指程序中可以使用该名字的部分,对于在函数开头声明的自动变量,其作用域是声明该变量的函数
//不同函数中声明的具有相同名字的各个局部变量之间没有任何关系,函数的参数也是这样,实际上可以将其看成是局部变量
//
//外部变量或函数的作用域从声明它的地方开始,到其所在的文件的末尾结束,例如:
//如果main sp val push pop是依次定义在某个文件中的5个函数或外部变量
//
//    main () {...}
//
//    int sp = 0;
//    double val[MAXVAL];
//
//    void push(double f) {...}
//
//    double pop(void) {...}
//
//那么在push和pop两个函数中不需要进行任何声明就可以通过名字访问变量sp和val,但是这两个变量名不能用在main函数中,push和pop也不能用在main函数中
//另一方面,如果要在外部变量的定义之前使用该变量,或者外部变量的定义与变量使用不在同一个源文件中,则必须在相应的变量声明中强制性地使用关键字extern
//将外部变量的声明与定义严格分开很重要,变量声明用于说明变量的属性,而变量定义除此之外还将引起存储器分配,如果将下列语句放在所有函数的外部:
//    int sp;
//    double val[MAXVAL];
//那么这两条语句将定义外部变量sp和val,并为之分配存储单元,同时这两条语句还可以作为该源文件中其余部分的声明,而下面两行语句:
//    extern int sp;
//    extern double val[];
//为源文件的其余部分声明了一个int类型的外部变量sp和一个double数组类型的外部变量val(该数组的长度在别的地方确定),但这两个声明并没有建立变量或为它们分配存储空间
//
//在一个源程序的所有源文件中,一个外部变量只能在某个文件中定义一次,且外部变量的初始化只能出现在其定义中
//而其他文件可以通过extern声明来访问它(定义外部变量的源文件也可以包含对该外部变量的extern声明)
//外部变量的定义中必须指定数组的长度,但extern声明则不一定要指定数组长度
//假定函数push和pop定义在一个文件中,而变量val和sp在另一个文件中定义并被初始化,则需要通过下面这些定义与声明把这些函数和变量绑定在一起
//在文件file1中:
//    extern int sp;
//    extern double val[];
//
//    void push(double f) {...}
//
//    double pop(void) {...}
//
//在文件file2中:
//    int sp = 0;
//    double val[MAXVAL];
//
//由于文件file1中的extern声明不仅放在函数定义的外面,而且还放在它们的前面,因此它们适用于该文件中的所有函数
//对于file1,这样一组声明就够了如果要在同一个文件中先使用后定义变量sp和val,也需要按照这种方式来组织文件
//
//之所以分割成多个文件,是考虑到在实际的程序中,它们分别来自于单独编译的库
//下面来考虑把上述的计算器程序分割到若干个源文件中的情况,这样分割:
//    将主函数main单独放在文件main.c中
//    将push和pop函数以及它们所使用的外部变量放在第二个文件stack.c中
//    将getop函数放在第三个文件getop.c中
//    将getch和ungetch函数放在第四个文件getch.c中
//
//此外还必须考虑定义和声明在这些文件之间的共享问题,尽可能把共享的部分集中在一起,这样就只需要一个副本,改进程序时也容易保证程序的正确性
//这些公共部分放在头文件calc.h中,在需要使用该头文件时使用#include指令将其包含进来
//
//静态变量
//某些变量比如文件stack.c中定义的变量sp与val以及文件getch.c定义的buf与bufp,它们仅供其所在的源文件中的函数使用,其他函数不能访问
//用static声明限定外部变量与函数,可以将其后声明的对象的作用域限定为被编译源文件的剩余部分
//通过static限定外部对象可以达到隐藏外部对象的目的,比如getch-ungetch复合结构需要共享buf和bufp两个变量,这样buf和bufp必须是外部变量
//但这两个对象不应该被调用getch与ungetch函数的调用者所访问
//要将对象指定为静态存储,可以在正常的对象声明之前加上关键字static作为前缀,如果把上述两个函数和两个变量放在一个文件中编译,如下所示:
//    static char buf[BUFSIZE];
//    static int bufp = 0;
//
//    int getch(void) {...}
//    void ungetch(int c) {...}
//
//那么其他函数就不能访问变量buf与bufp,因此这两个名字不会和同一程序中的其他文件中的相同的名字相冲突
//同样可以通过把变量sp与val声明为静态类型隐藏这两个由执行栈操作的push和pop函数使用的变量
//外部的static声明通常多用于变量,也可以用于声明函数,通常情况下函数名字是全局可访问的,对整个程序的各个部分而言都可见
//但是如果把函数声明为static类型,则该函数名除了对该函数声明所在的文件可见外,其他文件都无法访问
//static也可以用于声明内部变量,static类型的内部变量同自动变量一样,是某个特定函数的局部变量,只能在该函数中使用
//但它与自动变量不同的是,不管其所在函数是否被调用,它一直存在,而不像自动变量那样,随着所在函数的被调用和退出而存在和消失
//static类型的自动变量是一种只能在某个特定函数中使用但一直占据存储空间的变量
