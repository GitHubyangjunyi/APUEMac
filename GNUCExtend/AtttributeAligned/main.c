//
//  main.c
//  AtttributeAligned
//
//  Created by 杨俊艺 on 2019/7/7.
//  Copyright © 2019 杨俊艺. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[]) {
    
    int a = 1;
    int b = 2;
    char c1 = 3;
    char c2 = 4;
    
    printf("a:  %p\n", &a);
    printf("b:  %p\n", &b);
    printf("c1: %p\n", &c1);
    printf("c2: %p\n", &c2);
    
    ////结构体对齐////
    //接下来我们定义一个结构体,结构体内定义int/char和short三种成员并打印结构体的大小和各个成员的地址
    struct data
    {
        char a;
        int b;
        short c;
    };
    struct data s;
    printf("struct:\nsize:%d\n", sizeof(s));//12
    printf("a:%p\n", &s.a);//0
    printf("b:%p\n", &s.b);//4
    printf("c:%p\n", &s.c);//8
    //我们可以看到因为结构体的成员b需要4字节对齐,编译器在给成员a分配完空间后接着会空出3个字节,在满足4字节对齐的地址处才给成员b分配存储空间
    //接着是short类型的成员c占据2字节的存储空间,三个结构体成员一共占据4+4+2=10字节的存储空间,根据结构体的对齐规则
    //结构体的整体对齐要向结构体所有成员中大对齐字节数或其整数倍对齐,或者说结构体的整体长度要为其大成员字节数的整数倍
    //如果不是整数倍要补齐,因为结构体大成员int为4个字节,或者说按4字节的整数倍对齐,所以结构体的长度要为4的整数倍
    //要在结构体的末尾补充2个字节,所以后结构体的size为12个字
    
    //结构体成员中不同的排放顺序可能也会导致结构体的整体长度不一样,我们修改一下上面的程序
    struct data1
    {
        char a;
        short b;
        int c;
    };
    struct data1 s1;
    printf("structs:\nsize:%d\n", sizeof(s1));//8
    printf("a:%p\n", &s1.a);//0
    printf("b:%p\n", &s1.b);//2
    printf("c:%p\n", &s1.c);//4
    //我们调整了一些成员顺序会发现char型变量a和short型变量b分配在了结构体的前4个字节存储空间中,而且都满足各自的地址对齐
    //整个结构体大小是8字节,只造成一个字节的内存空洞,我们继续修改程序让short型的变量b按4字节对齐
    struct data2
    {
        char a;
        short b __attribute__((aligned(4)));
        int c;
    };
    struct data2 s2;
    printf("structs:\nsize:%d\n", sizeof(s2));//12
    printf("a:%p\n", &s2.a);//0
    printf("b:%p\n", &s2.b);//4
    printf("c:%p\n", &s2.c);//8
    //你会发现结构体的大小又重新变为12个字节,这是因为我们显式指定short变量以4字节地址对齐,导致变量a的后面填充了3个字节空间
    //int型变量c也要4字节对齐,所以变量b的后面也填充了2个字节,导致整个结构体的大小为12字节
    //我们不仅可以显式指定结构体内某个成员的地址对齐,也可以指定整个结构体的对齐方式
    struct data3
    {
        char a;
        short b;
        int c;
    }__attribute__((aligned(16)));
    struct data3 s3;
    printf("structs:\nsize:%d\n", sizeof(s3));//16
    printf("a:%p\n", &s3.a);//0
    printf("b:%p\n", &s3.b);//2
    printf("c:%p\n", &s3.c);//4
    //在这个结构体中各个成员一共占8个字节,整个结构体的对齐只要是大成员对齐字节数的整数倍即可,所以这个结构体整体就以8字节对齐
    //结构体的整体长度为8字节,但是我们在这里显式指定结构体整体以16字节对齐,所以编译器就会在这个结构体的末尾填充8个字节以满足16字节对齐的要求
    //导致结构体的总长度变为16字节
    
    //编译器一定会按照我们指定的大小对齐吗?
    //通过aligned属性我们可以显式指定一个变量的对齐方式,那么编译器就一定会按照我们指定的大小对齐吗
    //我们通过这个属性声明其实只是建议编译器按照这种大小地址对齐,但不能超过编译器允许的大值
    //一个编译器对每个基本数据类型,都有默认的大边界对齐字节数,如果你超过了编译器只能按照它规定的大对齐来给你的变量分配地址
    
    
    return 0;
}

//aligned和packed用来显式指定一个变量的存储边界对齐方式,一般我们定义一个变量,编译器会根据变量类型,按照默认的规则来给这个变量分配大小,
//按照默认的边界对齐方式分配一个地址,而使用atttribute这个属性声明就相当于告诉编译器按照我们指定的边界地址对齐去给这个变量分配存储空间
//GNU C通过attribute来声明aligned和packed属性指定一个变量或类型的对齐方式
//这两个属性用来告诉编译器在给变量分配存储空间时要按指定的地址对齐方式给变量分配地址
//如果你想定义一个变量在内存中以8字节地址对齐就可以这样定义
// int a __attribute__((aligned(8));
//通过aligned属性我们可以直接显式指定变量a在内存中的地址对齐方式
//aligned有一个参数表示要按几字节对齐,使用时要注意地址对齐的字节数必须是2的幂次方,否则编译就会出错
//一般情况下当我们定义一个变量,编译器会按照默认的地址对齐方式来给该变量分配一个存储空间地址,如果该变量是一个int型数据
//那么编译器就会按4字节或4字节的整数倍对齐,如果该变量是一个short型数据,那么编译器就会按2字节或2字节的整数倍边界对齐
//如果是一个char类型的变量,那么编译器就会按照1字节对齐
//
//a:    00402000
//b:    00402004
//c1:    00402008
//c2:    00402009
//
//通过运行结果我们可以看到对于int型数据,其在内存中的地址都是以4字节或4字节整数倍对齐的
//而char类型的数据其在内存中是以1字节对齐的
//变量c2就直接分配到了c1变量的下一个存储单元,不用像int数据那样考虑4字节对齐
//接下来修改一下程序指定变量c2按4字节对齐
//char c2 __attribute__((aligned(4))) = 4
//
//a:    00402000
//b:    00402004
//c1:    00402008
//c2:    0040200C
//
//通过运行结果可以看到字符变量c2由于使用aligned属性声明按照4字节边界对齐,所以编译器不可能再给其分配0x00402009这个地址
//因为这个地址不是4字节对齐的,编译器空出3个字节单元,直接从0x0040200C这个地址上给变量c2分配存储空间
//为什么要数据对齐?
//通过aligned这个属性声明虽然可以显式指定变量的地址对齐方式,但是也会因边界对齐造成一定的内存空洞,浪费一定的内存空间
//比如在上面这个程序中,0x00402009~0x0040200b这三个地址空间的存储单元就没有被使用
//既然地址对齐会造成一定的内存空洞,那我们为什么还要按照这种对齐方式去存储数据呢?一个主要原因就是这种对齐设置可以简化CPU和内存RAM之间的接口和硬件设计
//比如一个32位的计算机系统CPU读取内存时,硬件设计上可能只支持4字节或4字节倍数对齐的地址访问,CPU每次往内存RAM读写数据时一个周期可以读写4个字节
//如果我们把一个数据放在4字节对齐的地址上,那么CPU一次就可以把数据读写完毕,如果我们把一个int型数据放在一个非4字节对齐的地址上
//那CPU就要分2次才能把这个4字节大小的数据读写完毕,为了配合计算机的硬件设计,编译器在编译程序时,对于一些基本数据类型
//比如int/char/short/ﬂoat等会按照其数据类型的大小进行地址对齐,按照这种地址对齐方式分配的存储地址CPU一次就可以读写完毕,虽然边界对齐会造成一些内存空洞
//浪费一些内存单元,但是在硬件上的设计却大大简化了,这也是编译器给我们定义的变量分配地址时不同类型变量按不同字节数地址对齐的原因
//除了int/char/short/ﬂoat这些基本类型数据,对于一些复合类型数据也要满足地址对齐要求
//结构体对齐
//结构体作为一种复合数据类型,编译器在给一个结构体变量分配存储空间时不仅要考虑结构体内各个基本成员的地址对齐,还要考虑结构体整体的对齐
//为了结构体内的成员地址对齐,编译器可能会在结构体内填充一些空间,为了结构体整体对齐,编译器可能会在结构体的末尾填充一些空间
//接下来我们定义一个结构体,结构体内定义int/char和short三种成员并打印结构体的大小和各个成员的地址
//在这个结构体中各个成员一共占8个字节,通过前面学习我们知道整个结构体的对齐只要是大成员对齐字节数的整数倍即可
//所以这个结构体整体就以8字节对齐,结构体的整体长度为8字节,但是我们在这里显式指定结构体整体以16字节对齐
//所以编译器就会在这个结构体的末尾填充8个字节以满足16字节对齐的要求导致结构体的总长度变为16字节
